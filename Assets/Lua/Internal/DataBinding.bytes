local DataBinding = {}

local m_slotID = 0
local m_allEntries = {}
local m_allSlots = {}

local m_triggeringData = {}
local m_pendingBind = {}
local m_pendingUnbind = {}

local function NewSlot(key, callback, autoTrigger)
    if __UNITY_EDITOR and type(key) ~= "string" then
        error("DataBinding", "Only allow string as binding key")
    end
    m_slotID = m_slotID + 1
    local slot = {
        ID = m_slotID,
        key = key,
        callback = callback,
        autoTrigger = autoTrigger == nil and true or autoTrigger
    }
    m_allSlots[m_slotID] = slot
    return slot
end

local function DoBind(slot)
    local key = slot.key
    local entry = m_allEntries[key] or {slots = {}}
    m_allEntries[key] = entry
    entry.slots[slot] = slot
    if slot.autoTrigger then
        slot.callback(entry.data)
    end
end

local function DoUnbind(slot)
    local entry = m_allEntries[slot.key]
    if entry ~= nil then
        entry.slots[slot] = nil
    end
end

local function ResolveReplace(m)
    return tostring(DataBinding.GetData(string.match(m, "[^{}]+")))
end

local function Resolve(path)
    local trim = string.gsub(path, "/+$", "")
    return string.gsub(trim, "%{[^%}]+%}", ResolveReplace)
end

local function HandlePendingAndMarkTrigering(key)
    key = Resolve(key)

    local pending = m_pendingBind[key]
    if pending ~= nil then
        for slot in pairs(pending) do
            DoBind(slot)
        end
        m_pendingBind[key] = nil
    end

    pending = m_pendingUnbind[key]
    if pending ~= nil then
        for slot, _ in pairs(pending) do
            DoUnbind(slot)
        end
        m_pendingUnbind[key] = nil
    end

    m_triggeringData[key] = true
end

local function FindCallbackSlot(slots, callback)
    for k in pairs(slots) do
        local kCallback = k.callback
        if kCallback == callback then
            return true
        end
        if type(callback) == "userdata" and callback:Equals(kCallback) then
            return true
        end
    end
    return false
end

local function CheckTriggeringAndDoPending(slot, pendingTable)
    local key = slot.key
    local isTriggering = m_triggeringData[key]
    if isTriggering then
        local slots = pendingTable[key] or {}
        slots[slot] = slot
        pendingTable[key] = slots
    end
    return isTriggering
end

function DataBinding.Reset()
    m_slotID = 0
    for k, slots in pairs(m_allEntries) do
        if k == "slots" then
            for slot in pairs(slots) do
                slots[slot] = nil
                slot.callback = nil
            end
        end
        m_allEntries[k] = nil
    end
    for k, slot in pairs(m_allSlots) do
        slot.callback = nil
        m_allSlots[k] = nil
    end
    m_allSlots = {}
    m_triggeringData = {}
    m_pendingBind = {}
    m_pendingUnbind = {}
end

-- ** nil will not trigger
function DataBinding.TriggerData(key)
    key = Resolve(key)

    local entry = m_allEntries[key]
    if entry ~= nil then
        DataBinding.SetData(key, entry.data)
    end
end

function DataBinding.SetData(key, data)
    HandlePendingAndMarkTrigering(key)

    local entry = m_allEntries[key] or {slots = {}}
    m_allEntries[key] = entry
    entry.data = data

    for slot in pairs(entry.slots) do
        slot.callback(data)
    end

    m_triggeringData[key] = nil
end

function DataBinding.GetData(key)
    key = Resolve(key)
    warning("key", vardump(key))
    local entry = m_allEntries[key]
    if entry ~= nil then
        return entry.data
    end
end

function DataBinding.Bind(key, callback, autoTrigger)
    if key == nil then
        return
    end
    key = Resolve(key)
    local slot = NewSlot(key, callback, autoTrigger)

    if not CheckTriggeringAndDoPending(slot, m_pendingBind) then
        DoBind(slot)
    end
    return slot.ID
end

function DataBinding.Unbind(keyOrID, callback)
    if keyOrID == nil then
        return
    end
    -- ** 删除被延迟绑定
    local pendingSlots = m_pendingBind[keyOrID]
    if pendingSlots ~= nil then
        local slot = FindCallbackSlot(pendingSlots, callback)
        if slot then
            pendingSlots[slot] = nil
        end
    end

    -- ** 解绑定 先找到解绑定对象 再看是否需要被延迟 最后执行解绑定过程
    local slot
    if type(keyOrID) == "number" then
        slot = m_allSlots[keyOrID]
    else
        local entry = m_allEntries[keyOrID]
        if entry ~= nil then
            slot = FindCallbackSlot(entry.slots, callback)
        end
    end
    if slot ~= nil and not CheckTriggeringAndDoPending(slot, m_pendingUnbind) then
        DoUnbind(slot)
    end
end

--------------------------------------------------------------

function DataBinding.RegisterEvent(key, callback)
    return DataBinding.Bind(key, callback, false)
end

function DataBinding.UnregisterEvent(keyOrID, callback)
    DataBinding.Unbind(keyOrID, callback)
end

function DataBinding.TriggerEvent(key, ...)
    local entry = m_allEntries[key]
    if entry == nil then
        return
    end
    HandlePendingAndMarkTrigering(key)
    for slot, _ in pairs(entry.slots) do
        slot.callback(...)
    end
    m_triggeringData[key] = nil
end

return DataBinding
