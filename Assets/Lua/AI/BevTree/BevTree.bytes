local BevNode = require("AI/BevTree/BevNode")

local BevTree = {__index = BevNode}
setmetatable(BevTree, BevTree)

-- local function CreateBevTreeChildren(parent, children, context)
--     if parent == nil or children == nil then
--         return
--     end
--     for i = 1, #children do
--         local childData = children[i].data
--         -- local node
--         -- if childData.type == "ActionCreateSnippet" then
--         --     -- ** 直接将Snippet的内容拷贝到父节点下
--         --     local property = childData.actionCreateSnippet

--         --     local data = require("AI/Snippet/" .. property.fileName)
--         --     CreateBevTreeChildren(parent, data.children, context)
--         -- else
--         -- ** 生成对应type的节点
--         warning("childData", vardump(childData))

--         if script ~= nil then
--             -- ** TODO:
--             local node = script.ctor(childData)
--             node.context = context
--             parent:AddOrReplaceChild(node)
--             CreateBevTreeChildren(node, childData.children, context)
--         else
--             error("BevTree", "no node " .. childData.type .. " was defined. 请检查有没有对应节点type的lua脚本!")
--         end
--         -- end
--     end
-- end

function BevTree.CreateBevTreeBytes(file, context)
    local bytes = CS.System.IO.File.ReadAllBytes(file)
    local data = PBDecode("BevTree", bytes)
    return BevTree.CreateBevTree(data, context)
end

function BevTree.CreateBevTree(data, context)
    local root = BevTree.ctor(data)
    -- ** 行为树需要使用的所有上下文信息记录在这个里面，这是实例化的行为树中所有节点共享的
    root.context = context or {}
    -- root.data = data
    -- CreateBevTreeChildren(root, root.children, root.context)
    return root
end

function BevTree.CreateBevTreeFile(aiFileName, context)
    if string.isnilorempty(aiFileName) then
        return
    end
    local data = require("AI/" .. aiFileName)
    return BevTree.CreateBevTree(data, context)
end

function BevTree.ctor(data)
    local nodes = data.nodes
    local allNodes = {}
    local rootNode = BevNode.ctor(BevTree, data)
    -- ** 构造所有的Node
    for _, nodeData in pairs(nodes) do
        local script
        if nodeData.uid == data.primeNodeUid then
            script = require("AI/BevTree/Bev" .. nodeData.type)
            local node = script.ctor(nodeData)
            node.root = rootNode
            rootNode:AddOrReplaceChild(node)
        else
            if string.starts(nodeData.type, "Condition") then
                script = require("AI/BevTree/Conditions/" .. nodeData.taskType)
            elseif string.starts(nodeData.type, "Action") then
                script = require("AI/BevTree/Actions/" .. nodeData.taskType)
            else
                script = require("AI/BevTree/Bev" .. nodeData.type)
            end
            local node = script.ctor(nodeData)
            -- ** 占位
            node.root = rootNode
            allNodes[node.uid] = node
        end
    end
    -- ** 根据Connection连接所有的Node到children字段
    local connections = data.connections
    local allConnections = {}
    for _, connection in pairs(connections) do
        allConnections[connection.uid] = connection
    end

    local Connect
    Connect = function(node)
        if node ~= nil then
            for _, out in pairs(node.data.outConnectionsUid) do
                local targetNode = allNodes[allConnections[out].targetNodeUid]
                node:AddOrReplaceChild(targetNode)
                Connect(targetNode)
            end
        end
    end
    Connect(rootNode.children[1])
    return rootNode
end

function BevTree:Init()
    self.context.currentTime = 0
    self.context.localVars = {}
    self.context.countDownVars = {}
    BevNode.Init(self)
end

function BevTree:Uninit()
    self.running = false
    BevNode.Uninit(self)
end

function BevTree:Reset()
    if self.running == nil or self.running == true then
        for k, _ in pairs(self.context.localVars) do
            self.context.localVars[k] = nil
        end
        for k, _ in pairs(self.context.countDownVars) do
            self.context.countDownVars[k] = nil
        end
        BevNode.Reset(self)
    end
end

function BevTree:Run(delta)
    local context = self.context
    -- if #self.children == 0 then
    --     return
    -- end
    -- if #self.children > 1 then
    --     warning("BevTree", "行为树根节点下有两个以上的节点，多于1个的节点永远不会被执行到！")
    -- end
    self.running = true
    context.currentTime = context.currentTime + delta
    context.deltaTime = delta
    for k, var in pairs(self.context.countDownVars) do
        self.context.countDownVars[k] = var - delta
    end

    local process = context.frequency == nil
    if context.frequency ~= nil and context.frequency > 0 then
        self.frequencyTime = self.frequencyTime or context.frequency
        self.frequencyTime = self.frequencyTime - delta
        if self.frequencyTime <= 0 then
            self.frequencyTime = context.frequency
            process = true
        end
    end

    if process then
        local startNode = self.children[1]
        local result = startNode:Run()
        -- warning("result", vardump(result))
        startNode:LogRecord(result)
    end
end

return BevTree
