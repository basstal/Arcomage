local ResourceType = CS.CostType
GameMainCS = nil
local CurrentStage = nil
GameData = {
    currentPlayer = 0
}

local function SetCurrentPlayer(n)
    GameData.currentPlayer = n
    DB.SetData("CurrentPlayer", n)
end

function TurnRound()
    print("TurnRound")
    GameMainCS.round = GameMainCS.round + 1
    warning("GameMainCS.round", vardump(GameMainCS.round))
    if GameMainCS.round == 1 then
        DB.TriggerEvent("Player/GenHandCards", 5)
        SetCurrentPlayer(GameMainCS.firstPlayer)
    else
        DB.TriggerEvent("Player/RecycleHandCards")
        DB.TriggerEvent("Player/GenHandCards", 5)
        SetCurrentPlayer(GameData.currentPlayer % 2 + 1)
        local player = DB.GetData("Player{CurrentPlayer}")
        PlayerResourceGrowth(player, ResourceType.Recruit)
        PlayerResourceGrowth(player, ResourceType.Gem)
        PlayerResourceGrowth(player, ResourceType.Brick)
    end
    CurrentStage = PlayerRound
end

function GameMainCSCallback()
    CurrentStage = TurnRound
end

function GameStart()
    print("GameStart")
    REF.Start:SetActive(false)
    GameMainCS.round = 0
    GameMainCS:Init(GameMainCSCallback)
    SetCurrentPlayer(0)
    GameData.playerSwitched = false
end

function Awake()
    GameMainCS = this:GetComponent(typeof(CS.GameMain))

    BindButtonEvent(REF.Start, GameStart)
    DB.RegisterEvent("Main/ShowUseCard", OnShowUseCard)
    DB.RegisterEvent("Main/PlayerSwitch", OnPlayerSwitch)
    DB.SetData("Main", _ENV)
end

function OnShowUseCard(cardGameObj)
    cardGameObj.transform:SetParent(this.transform, true)
    local doTween = cardGameObj:GetComponent(typeof(CS.DG.Tweening.DOTweenAnimation))
    doTween:DOPlay()
end

function Update()
    if CurrentStage ~= nil then
        CurrentStage()
    end
end

function PlayerResourceGrowth(player, type)
    local gamePlayerCS = player.GamePlayerCS
    if type == ResourceType.Brick then
        gamePlayerCS.brick = gamePlayerCS.brick + gamePlayerCS.brickIncRate
    elseif type == ResourceType.Recruit then
        gamePlayerCS.recruit = gamePlayerCS.recruit + gamePlayerCS.recruitIncRate
    else
        gamePlayerCS.gem = gamePlayerCS.gem + gamePlayerCS.gemIncRate
    end
end

function OnPlayerSwitch(result)
    -- ** 再次出牌直接不改变当前玩家进入PlayerRound
    if result ~= nil and result.playAgain then
        local player = DB.GetData("Player{CurrentPlayer}")
        player.OnGenHandCards(1)
        CurrentStage = PlayerRound
        return
    end
    if GameData.playerSwitched then
        CurrentStage = TurnRound
    else
        local player = DB.GetData("Player{CurrentPlayer}")
        player.OnRecycleHandCards()

        SetCurrentPlayer(GameData.currentPlayer % 2 + 1)

        GameData.playerSwitched = true
        print(" playerSwitched : " .. tostring(GameData.playerSwitched))
        CurrentStage = PlayerRound
    end
end

function PlayerRound()
    print("PlayerRound")
    local handCards = DB.GetData("Player{CurrentPlayer}/HandCards")
    local parentTrans = REF.HandCardsLayout.transform
    for _, cardData in pairs(handCards) do
        local trans = cardData.transform
        trans:SetParent(parentTrans, false)
    end
    CS.UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(parentTrans)
    CurrentStage = nil
end
