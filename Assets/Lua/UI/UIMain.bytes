local ResourceType = CS.ResourceType
local U = require("Utils")
local AI = require("Simple")

local BOARD_CARD_LIMIT = 20
local HAND_CARD_INIT = 3
local HAND_CARD_LIMIT = 6
local GameMainCS
GameData = {
    isStarted = false,
    players = {},
    currentPlayerIdx = 0,
    firstPlayer = 0,
    CurrentStage = function()
    end,
    CardEvents = {}
}

function TurnRound()
    print("TurnRound")
    GameMainCS.round = GameMainCS.round + 1
    GameData.CurrentStage = PlayerRandomStart
end

function GameEnd()
    print("GameEnd")
    if GameData.winner ~= nil then
        warning("获胜者是玩家 : " .. tostring(GameData.winner))
    end
    GameData.winner = nil
    GameData.isStarted = false
    for i = 0, #REF.MyCards - 1 do
        -- print(REF.MyCards[i].root.gameObject)
        CS.UnityEngine.GameObject.Destroy(REF.MyCards[i].root.gameObject)
    end
    for i = 0, #REF.EnemyCards - 1 do
        -- print(REF.MyCards[i].root.gameObject)
        CS.UnityEngine.GameObject.Destroy(REF.EnemyCards[i].root.gameObject)
    end
    REF.Player2Name.DOTweenAnimation:DOPause()
    REF.Player1Name.DOTweenAnimation:DOPause()
end

-- function InitPlayerCS(p)
--     local res = CS.Resource()
--     res.Type = ResourceType.Monster
--     res.Count = 5
--     res.Growth = 1
--     res.GrowthDynamic = 0
--     p.Resources:Add(res)

--     res = CS.Resource()
--     res.Type = ResourceType.Jewelry
--     res.Count = 5
--     res.Growth = 1
--     res.GrowthDynamic = 0
--     p.Resources:Add(res)

--     res = CS.Resource()
--     res.Type = ResourceType.Brick
--     res.Count = 5
--     res.Growth = 1
--     res.GrowthDynamic = 0
--     p.Resources:Add(res)

--     p.Wall = CS.BuildingWall()
--     p.Wall.Hp = 10
--     p.Castle = CS.BuildingCastle()
--     p.Castle.Hp = 10
--     p.Tower = CS.BuildingTower()
--     p.Tower.Hp = 10
--     p.College = CS.BuildingCollege()
--     p.College.Exist = false
--     print(string.format("player %s inited", p.Id))
-- end

function GameMainCSCallback()
    DB.TriggerEvent("Player/GenHandCards", GameMainCS, 5)
    GameData.isStarted = true
    GameData.CurrentStage = TurnRound
end

function GameStart()
    print("GameStart")

    if GameData.isStarted then
        GameEnd()
    end
    GameMainCS:Init(GameMainCSCallback)
    GameData.CardEvents = {}
    GameData.currentPlayerIdx = 0
    GameData.playerSwitched = false
end

function DrawCard()
    -- local boardCards =
    --     table.select(
    --     player.cards,
    --     function(v)
    --         local f =
    --             table.find(
    --             player.handCards,
    --             function(_, c)
    --                 return c.uid == v.uid
    --             end
    --         )
    --         if f == nil then
    --             return v
    --         end
    --     end
    -- ):toarray()
    -- local _, moreHandCards = GenHandCards(player.playerCS, boardCards, count)
    -- table.append(player.handCards, moreHandCards)
end

function SkipRound()
    if GameData.CurrentStage == WaitPlayer then
        print("SkipRound")
        local player = GameData.players[GameData.currentPlayerIdx]
        if #player.handCards < HAND_CARD_LIMIT then
            DrawCard(player, 1)
        end
        PlayerSwitch()
    end
end

function Awake()
    GameMainCS = this:GetComponent(typeof(CS.GameMain))

    BindButtonEventCS(REF.Start, GameStart)
    -- REF.SkipRound.gameObject:BindButtonEvent(SkipRound)
    DB.Bind("Left/Player", UIRefresh)
    DB.Bind("Right/Player", UIRefresh)
    DB.RegisterEvent("SkipRound", SkipRound)
    -- GameData.textures = {}
    -- GameData.textures.card = CS.AssetUtility.LoadTexture2D("Sprites/Card1")
    -- GameData.textures.enemyCard = CS.AssetUtility.LoadTexture2D("Sprites/Card1")
end

function UIRefresh(player)
    if player == nil then
        return
    end
    local node = REF.MyResources
    local nodeBuildings = REF.MyBuildings
    if player.playerCS.Id == 2 then
        node = REF.EnemyResources
        nodeBuildings = REF.EnemyBuildings
    end
    local resources = U.HandlePlayerResources(player)

    node.TextMeshProUGUI.text =
        string.format(
        -- "resources\n\nMonster [%d]\nJewelry [%d]\nBricks [%d]\nFood [%d]\nLabor [%d]\n",
        "怪兽 [%d/%d]\n珠宝 [%d/%d]\n砖块 [%d/%d]",
        resources[ResourceType.Monster].Count,
        resources[ResourceType.Monster].Growth + resources[ResourceType.Monster].GrowthDynamic,
        resources[ResourceType.Jewelry].Count,
        resources[ResourceType.Jewelry].Growth + resources[ResourceType.Jewelry].GrowthDynamic,
        resources[ResourceType.Brick].Count,
        resources[ResourceType.Brick].Growth + resources[ResourceType.Brick].GrowthDynamic
    )

    -- resources[ResourceType.Food].Count,
    -- resources[ResourceType.Labor].Count )

    node.TextMeshProUGUI.color = player.color
    nodeBuildings.TextMeshProUGUI.text =
        string.format(
        -- "buildings\n\nWall [%d]\nCastle [%d]\nTower [%d]\nCamp [%d]\nFurnace [%d]\nCave [%d]\nCollege [%s]",
        "塔楼 [%d]\n城堡 [%d]\n城墙 [%d]\nCollege [%s]",
        player.playerCS.Tower.Hp,
        player.playerCS.Castle.Hp,
        player.playerCS.Wall.Hp,
        -- player.playerCS.Camp.Hp,
        -- player.playerCS.Furnace.Hp,
        -- player.playerCS.Cave.Hp,
        player.playerCS.College.Exist
    )
    nodeBuildings.TextMeshProUGUI.color = player.color
end

function Update()
    if GameData.isStarted then
        if CS.UnityEngine.Input.GetKeyDown(CS.UnityEngine.KeyCode.Alpha1) then
            local current = GameData.players[GameData.currentPlayerIdx]
            if current ~= nil then
                for i, card in pairs(current.handCards) do
                    if card.note ~= nil then
                        print(string.format("第 [%s] 张 uid[%s] 效果 : %s ", i, card.uid, card.note))
                    end
                end
            end
        end
        -- local current = CS.UnityEngine.EventSystems.EventSystem.current
        -- print(current)
        -- print(current.currentInputModule)
        -- print(GameData.CurrentStage)
        GameData.CurrentStage()
    end
end

function CheckWinner()
    local p1 = GameData.players[1]
    local p2 = GameData.players[2]
    if GameMainCS.round == 10 then
        if p1.playerCS.Castle.Hp > p2.playerCS.Castle.Hp then
            GameData.winner = "player1"
            print("获胜原因：p1城堡 > p2城堡")
        elseif p2.playerCS.Castle.Hp > p1.playerCS.Castle.Hp then
            GameData.winner = "player2"
            print("获胜原因：p2城堡 > p1城堡")
        else
            warning("平局")
        end
        return true
    else
        local p1Total = U.GetAllBuildingsHp(p1)
        local p2Total = U.GetAllBuildingsHp(p2)
        if p1Total == 0 and p2Total ~= 0 then
            GameData.winner = "player2"
            print(string.format("获胜原因：p1Total : %s, p2Total : %s", p1Total, p2Total))
        elseif p2Total == 0 and p1Total ~= 0 then
            GameData.winner = "player1"
            print(string.format("获胜原因：p1Total : %s, p2Total : %s", p1Total, p2Total))
        elseif p1Total == 0 and p2Total == 0 then
            warning("平局")
        else
            return false
        end
        return true
    end
end

function PlayerResourceGrowth(resources, type, limit)
    local growth = resources[type].Growth
    local growthDynamic = resources[type].GrowthDynamic
    local result = growth + growthDynamic
    if resources[type].Count > limit or limit == 0 then
        result = 0
    end
    -- local result = 0
    -- for i = 0, growth.Count - 1 do
    -- local resGrowth = growth[i]
    -- if resGrowth.IsConditional == false then
    -- local rtc = resources[resGrowth.GrowthByType].Count
    -- local baseGrowthRate = resGrowth.BaseGrowthRate
    -- if resources[type].Count > limit or limit == 0 then
    -- baseGrowthRate = -1.0
    -- end
    -- print("资源产量", string.format("%s , baseGrowthRate : %f", type, baseGrowthRate))
    -- result = result + rtc * (baseGrowthRate + resGrowth.DynamicGrowthRate)
    -- else
    -- print("未处理的条件增援增长率", resGrowth)
    -- end
    -- end
    print("资源改变", string.format("%s , count : %d", type, result))
    return result
end

function ResourceGrowth(player)
    local resources = U.HandlePlayerResources(player)
    -- local recordResources = {
    -- 	[ResourceType.Monster] = resources[ResourceType.Monster].Count,
    -- 	[ResourceType.Jewelry] = resources[ResourceType.Jewelry].Count,
    -- 	[ResourceType.Brick] = resources[ResourceType.Brick].Count,
    -- 	[ResourceType.Food] = resources[ResourceType.Food].Count,
    -- 	[ResourceType.Labor] = resources[ResourceType.Labor].Count,
    -- }
    local limit = U.GetResourceLimit(player, ResourceType.Monster)
    local nMonster = PlayerResourceGrowth(resources, ResourceType.Monster, limit)
    limit = U.GetResourceLimit(player, ResourceType.Jewelry)
    local nJewelry = PlayerResourceGrowth(resources, ResourceType.Jewelry, limit)
    limit = U.GetResourceLimit(player, ResourceType.Brick)
    local nBrick = PlayerResourceGrowth(resources, ResourceType.Brick, limit)
    -- limit = U.GetResourceLimit(player, ResourceType.Food)
    -- local nFood = PlayerResourceGrowth(resources, ResourceType.Food, limit)
    -- limit = U.GetResourceLimit(player, ResourceType.Labor)
    -- local nLabor = PlayerResourceGrowth(resources, ResourceType.Labor, limit)

    U.ResChange(player, ResourceType.Monster, nMonster)
    U.ResChange(player, ResourceType.Jewelry, nJewelry)
    U.ResChange(player, ResourceType.Brick, nBrick)
    -- U.ResChange(player, ResourceType.Food, nFood)
    -- U.ResChange(player, ResourceType.Labor, nLabor)
end
function RoundEnd()
    print("RoundEnd")
    GameData.playerSwitched = false
    GameData.currentPlayerIdx = 0
    -- GameData.nextPlayer = 0

    -- ** 处理所有Card事件
    local remainEvents = {}
    for _, eventWrap in ipairs(GameData.CardEvents) do
        if eventWrap.triggerRound == 0 then
            eventWrap.event()
        else
            eventWrap.triggerRound = eventWrap.triggerRound - 1
            table.insert(remainEvents, eventWrap)
        end
    end
    GameData.CardEvents = remainEvents

    -- ** 双方玩家产量计算
    -- for _, player in pairs(GameData.players) do

    -- local nodeGrowth = REF.MyResourcesGrowth
    -- if player.playerCS.Id == 2 then
    -- 	nodeGrowth = REF.EnemyResourcesGrowth
    -- end
    -- nodeGrowth.TextMeshProUGUI.text = string.format("Growth\n\n [%d]\n[%d]\n[%d]", nMonster, nJewelry, nBrick)
    -- nodeGrowth.TextMeshProUGUI.color = player.color
    -- end

    -- ** 若卡牌数没有到达上限，各从卡牌池中获得一张手牌
    for _, player in pairs(GameData.players) do
        if #player.handCards < HAND_CARD_LIMIT then
            DrawCard(player, 1)
        end
    end
    -- ** 刷新界面
    DB.SetData("Left/Player", GameData.players[1])
    DB.SetData("Right/Player", GameData.players[2])

    -- ** 后续检查
    if CheckWinner() then
        GameEnd()
    else
        GameData.CurrentStage = TurnRound
    end
end

function PlayerSwitch(playAgain)
    if GameData.currentPlayerIdx ~= 0 then
        REF[string.format("Player%dName", GameData.currentPlayerIdx)].DOTweenAnimation:DOPause()
    end
    -- ** 再次出牌直接不改变当前玩家进入PlayerRound
    if playAgain then
        GameData.CurrentStage = PlayerRound
        return
    end
    if GameData.playerSwitched then
        ResourceGrowth(GameData.players[GameData.currentPlayerIdx])
        GameData.CurrentStage = RoundEnd
    else
        if GameData.currentPlayerIdx == 0 then
            GameData.currentPlayerIdx = GameData.firstPlayer
        else
            ResourceGrowth(GameData.players[GameData.currentPlayerIdx])
            GameData.currentPlayerIdx = GameData.firstPlayer % 2 + 1
            GameData.playerSwitched = true
            print(" playerSwitched : " .. tostring(GameData.playerSwitched))
        end
        GameData.CurrentStage = PlayerRound
    end
end

function WaitPlayer()
    -- print("WaitPlayer")
    local player = GameData.players[GameData.currentPlayerIdx]
    if player.useAI then
        AI.TryUseCard(player)
    end
    -- REF.CurrentPlayerName.TextMeshProUGUI.text = string.format("Player %s, id %s", player.playerCS.Name, player.playerCS.Id)
end

function PlayerRound()
    print("PlayerRound")
    REF[string.format("Player%dName", GameData.currentPlayerIdx)].DOTweenAnimation:DORestart()
    local player = GameData.players[GameData.currentPlayerIdx]
    print(player.playerCS.Id)

    local rootName = "MyCards"
    local enemyRootName = "EnemyCards"
    if player.playerCS.Id == 2 then
        rootName, enemyRootName = enemyRootName, rootName
    end

    REF[enemyRootName].gameObject:SetActive(false)
    for i = 0, #REF[enemyRootName] - 1 do
        REF[enemyRootName][i].root.LuaBehaviour.enabled = false
    end
    REF[rootName].gameObject:SetActive(true)

    REF.BoardCards.TextMeshProUGUI.text = "BoardCards Count:" .. tostring(#player.cards - #player.handCards)
    player.cardPrefabs = player.cardPrefabs or {}
    -- if #player.cardPrefabs ~= #player.handCards then
    for index, card in ipairs(player.handCards) do
        local prefab = player.cardPrefabs[index]
        if prefab == nil then
            local root = CS.UnityEngine.GameObject.Find(rootName)
            prefab = CS.AssetUtility.InstantiatePrefab("Prefabs/UI/Card")
            prefab.transform:SetParent(root.transform, false)
            player.cardPrefabs[index] = prefab
        end
        prefab:SetActive(true)
        local behaviour = prefab.transform:GetComponent(typeof(CS.LuaBehaviour))
        behaviour.enabled = true
        behaviour.sandbox.Init(player, card)

        card.sandbox = behaviour.sandbox
    end
    if #player.cardPrefabs > #player.handCards then
        for i = #player.handCards + 1, #player.cardPrefabs do
            player.cardPrefabs[i]:SetActive(false)
        end
    end
    -- end
    print(string.format("player id : %s, player cardPrefabs : %s ", player.playerCS.Id, #player.cardPrefabs))
    GameData.CurrentStage = WaitPlayer
end

function PlayerRandomStart()
    print("PlayerRandomStart")
    -- GameData.firstPlayer = math.random(1, 2)
    GameData.firstPlayer = 1
    PlayerSwitch()
end
