
local FCLogic = require("Logic/FCode/FCLogic")

local CC = {}
CC.__index = CC
local names = {}

function CC.New()
    local n = {
        fcodeTimingRecords = {},
        -- ** 这里应该是一个 弱键【mode = 'k'】 的table
        fcodeExcludeRecords = nil,
        envInput = setmetatable({}, {
            __newindex = function(table, key, val) 
                if names[key] == nil then 
                    names[key] = true
                end 
                rawset(table, key, val)
            end}),
        envNames = names,
    }
    setmetatable(n, CC)
    return n
end

function CC:Init(FillEnvInputDelegate)
    local envInput = self.envInput
    for k in pairs(envInput) do
        envInput[k] = nil
    end
    local envNames = self.envNames
    for name in pairs(envNames) do
        envNames[name] = nil
    end
    self.FillEnvInput = FillEnvInputDelegate
    self:ClearRecords()
    self.fcodeExcludeRecords = nil
end

function CC:OnDestroy()
    local envInput = self.envInput
    for k in pairs(envInput) do
        envInput[k] = nil
    end
    local envNames = self.envNames
    for name in pairs(envNames) do
        envNames[name] = nil
    end
    self.envInput = nil
    self.FillEnvInput = nil
    self:ClearRecords()
    self.fcodeTimingRecords = nil
    self.fcodeExcludeRecords = nil
    for _, func in pairs(FCLogic) do
        setfenv(func, nil)
    end
end

local envLookup = { 
    __index = function(this, key)
        local prefix = key:sub(1, 1)
        -- 查询当前执行中的Logic的字典中的内容
        if prefix == "@" then
            local sub_key = key:sub(2)
            if sub_key:len() > 0 then
                local result = this.fcodeRecord.dict[sub_key]
                if result == nil then
                    if __UNITY_EDITOR then
                        info("FCode", string.format([=[FCodeCall info! due to key search %s don't exist in dict.
                        if you wanna call a function, name format like "fc_xxxxx", 
                    else if your wanna query a field, make sure your key is predefined. 
                        please check your code and try again.]=], key))
                    end
                end
                return result
            else
                return this.fcodeRecord
            end
        else
            if FCLogic[key] == nil then
                if rawget(_G, key) ~= nil then
                    return _G[key]
                end
            else
                return setfenv(FCLogic[key], this)
            end
        end
    end, 
}

local function FCodeCall(lua, env)
    env = setmetatable(env, envLookup)
    local f = setfenv(lua, env)
    local status, err = pcall(f)
    if status == false then
        warning("FCode", string.format("FCodeCall failed! error:%s\n env:\n%s", err, vardump(env)))
    else
        return err
    end
end

function CC:FCodeEnableScript(scriptName, externalDict)
    if string.isnilorempty(scriptName) then return end
    local reused = false
    local dict = externalDict or {}
    for _, fcodeRecords in pairs(self.fcodeTimingRecords) do
        for _, fcodeRecord in pairs(fcodeRecords) do
            if fcodeRecord.scriptName == scriptName and fcodeRecord.executeTimes == 0 then
                fcodeRecord.dict = dict
                fcodeRecord.executeTimes = -1
                reused = true
            end
        end
    end
    if not reused then
        local package = loadPackage(string.format("Logic/FCode/%s", scriptName))
        if package ~= nil then
            local functionMap = setmetatable({}, {__index = _ENV})
            setfenv(package, functionMap)()
            for functionName, v in pairs(functionMap) do
                if type(v) == "function" then
                    local timing = PBEnum.FCodeTiming[functionName]
                    if timing == nil then
                        warning("FCode", string.format("function name %s isn't a FCodeTiming enum", functionName))
                    else
                        local fcodeRecord = {
                            type = "script",
                            scriptName = scriptName,
                            lua = v,
                            timing = timing,
                            dict = dict,
                            executeTimes = -1,
                            env = {},
                        }
                        self.fcodeTimingRecords[timing] = self.fcodeTimingRecords[timing] or {}
                        table.insert(self.fcodeTimingRecords[timing], fcodeRecord)
                    end
                end
            end
        end
    end
end

function CC:FCodeDisableScript(scriptName)
    if not string.isnilorempty(scriptName) then
        for _, fcodeRecords in pairs(self.fcodeTimingRecords) do
            for _, fcodeRecord in pairs(fcodeRecords) do
                if fcodeRecord.scriptName == scriptName then
                    fcodeRecord.executeTimes = 0
                end
            end
        end
    end
end

-- ** 一般情况下不需要remove
function CC:FCodeRemove(configId)
    if configId == nil or configId == 0 then return end
    local envInput = self.envInput
    local envNames = self.envNames
    for _, fcodeRecords in pairs(self.fcodeTimingRecords) do
        for i = #fcodeRecords, 1, -1 do
            local fcodeRecord = fcodeRecords[i]
            if fcodeRecord.id == configId then
                local env = fcodeRecord.env
                for name in pairs(envNames) do
                    env[name] = envInput[name]
                end
                self:FCodeRevert(fcodeRecord, env)
                table.remove(fcodeRecords, i)
            end
        end
    end
end

function CC.ResolveVars(configId, env)
    local vars = {}
    if configId == nil or configId == 0 then return vars end
    local names = string.split(configId, "/")
    if #names == 2 then
        local logicList = require(string.format("FCode/%s", names[1]))
        if logicList ~= nil and logicList.vars ~= nil then
            env = env or {}
            local instances = logicList.instances
            if instances ~= nil then
                env.config = instances[names[2]] or instances.default
            end
            for varName, varFunc in pairs(logicList.vars) do
                vars[varName] = FCodeCall(varFunc, env)
            end
        end
    end
    return vars
end

-- ** 注意这里的第二个参数传进来的table必须是一个可以任意修改的table，最好在之前Clone一份数据，以防后续的修改把原始数据改坏了
function CC:ResolveFCode(configId, externalDict, executeTimes)
    if configId == nil or configId == 0 then return end
    local names = string.split(configId, "/")

    if #names == 2 then
        local logicId = names[1]
        local logicList = require(string.format("FCode/%s", logicId))
        if logicList ~= nil then
            local reused = false
            local dict = externalDict or {}
            -- ** 重用
            for _, fcodeRecords in pairs(self.fcodeTimingRecords) do
                for _, fcodeRecord in pairs(fcodeRecords) do
                    if fcodeRecord.id == configId and fcodeRecord.logicId == logicId and fcodeRecord.executeTimes == 0 then
                        fcodeRecord.dict = dict
                        fcodeRecord.executeTimes = executeTimes or 1
                        fcodeRecord.revertData = {}
                        reused = true
                    end
                end
            end
            if not reused then
                -- ** 不重用
                local instances = logicList.instances or {}
                local config = instances[names[2]]
                config.id = configId
                for k, logic in pairs(logicList) do
                    if type(k) == "number" then
                        local fcodeRecord = {
                            type = "classic",
                            id = configId,
                            logicId = logicId,
                            logic = logic,
                            timing = logic.timing,
                            dict = dict,
                            executeTimes = executeTimes or -1,
                            revertData = {},
                            vars = logicList.vars,
                            env = {},
                            config = config,
                        }
                        self.fcodeTimingRecords[logic.timing] = self.fcodeTimingRecords[logic.timing] or {}
                        table.insert(self.fcodeTimingRecords[logic.timing], fcodeRecord)
                    end
                end
            end
        end
    end
end

function CC:PauseByDict(dict)
    for _, fcodeRecords in pairs(self.fcodeTimingRecords) do
        for _, fcodeRecord in pairs(fcodeRecords) do
            if fcodeRecord.dict == dict then
                fcodeRecord.executeTimes = 0
            end
        end
    end
end

function CC:PauseAll()
    for _, fcodeRecords in pairs(self.fcodeTimingRecords) do
        for _, fcodeRecord in pairs(fcodeRecords) do
            fcodeRecord.executeTimes = 0
        end
    end
end

function CC:FCodeRevertAll(outterEnv)
    local envNames = self.envNames
    local envInput = self.envInput
    for _, fcodeRecords in pairs(self.fcodeTimingRecords) do
        for _, fcodeRecord in pairs(fcodeRecords) do
            local env
            if outterEnv ~= nil then
                env = outterEnv
            else
                env = fcodeRecord.env
                for name in pairs(envNames) do
                    env[name] = envInput[name]
                end
            end
            self:FCodeRevert(fcodeRecord, env)
        end
    end
end

function CC:FCodeRevert(fcodeRecord, env)
    if env ~= nil then
        env.fcode = self
        env.config = fcodeRecord.config
        env.fcodeRecord = fcodeRecord
        FCodeCall(FCLogic.fc_revertData, env)
    end
end

function CC:FCodeExecute(timing, outterEnv)
    local records = self.fcodeTimingRecords[timing]
    if records == nil then return end
    local envInput = self.envInput
    local envNames = self.envNames
    for _, fcodeRecord in pairs(records) do
        -- ** 添加可选的排除某些FCodeRecord的逻辑
        if fcodeRecord.executeTimes ~= 0 and (self.fcodeExcludeRecords == nil or not self.fcodeExcludeRecords[fcodeRecord]) then
            local env
            if outterEnv ~= nil then
                env = outterEnv
            else
                env = fcodeRecord.env
                for name in pairs(envNames) do
                    env[name] = envInput[name]
                end
            end
            env.fcode = self
            env.fcodeRecord = fcodeRecord
            if fcodeRecord.type == "classic" then
                env.config = fcodeRecord.config
                local logic = fcodeRecord.logic
                local condition = logic.condition
                env.conditionPassed = condition == nil
                if condition ~= nil then
                    FCodeCall(condition, env)
                end
                local command = logic.command
                if command ~= nil and env.conditionPassed == true then
                    if fcodeRecord.vars ~= nil then
                        for varName, varFunc in pairs(fcodeRecord.vars) do
                            env[varName] = FCodeCall(varFunc, env)
                        end
                    end
                    FCodeCall(command, env)
                    -- ** 这里不管报错的状态如何，执行次数都减1（报错了肯定要把错解决掉，保证逻辑是通的）
                    if fcodeRecord.executeTimes > 0 then
                        fcodeRecord.executeTimes = fcodeRecord.executeTimes - 1
                    end
                end
            elseif fcodeRecord.type == "script" then
                FCodeCall(fcodeRecord.lua, env)
            end
        end
    end
end

function CC:FCodeHasTiming(timing)
    return self.fcodeTimingRecords[timing] ~= nil
end

function CC:ExecuteTimeMax()
    local executeTimesMax = 0
    for _, fcodeRecords in pairs(self.fcodeTimingRecords) do
        for _, fcodeRecord in pairs(fcodeRecords) do
            executeTimesMax = math.max(fcodeRecord.executeTimes, executeTimesMax)
        end
    end
    return executeTimesMax
end

function CC:FillEnvInput()
    warning("FCode", "no FillEnvInputDelegate! but you are trying to call FillEnvInput")
end

function CC:ClearRecords()
    for i, records in pairs(self.fcodeTimingRecords) do
        for ri, record in pairs(records) do
            local env = record.env
            for k in pairs(env) do
                env[k] = nil
            end
            for k in pairs(record) do
                record[k] = nil
            end
            records[ri] = nil
        end
        self.fcodeTimingRecords[i] = nil
    end
end

return CC