local BevConst = require("BevTree/BevConst")
local BevNode = require("BevTree/BevNode")

local BevTree = {__index = BevNode}
setmetatable(BevTree, BevTree)

local function CreateBevTreeChildren(parent, children, context)
    if parent == nil or children == nil then
        return
    end
    for i = 1, #children do
        local childData = children[i].data
        -- local node
        -- if childData.type == "ActionCreateSnippet" then
        --     -- ** 直接将Snippet的内容拷贝到父节点下
        --     local property = childData.actionCreateSnippet

        --     local data = require("AI/Snippet/" .. property.fileName)
        --     CreateBevTreeChildren(parent, data.children, context)
        -- else
        -- ** 生成对应type的节点
        local script
        if string.starts(childData.type, "Condition") then
            script = require("Logic/BevTree/Conditions/" .. childData.taskType)
        elseif string.starts(childData.type, "Action") then
            script = require("Logic/BevTree/Actions/" .. childData.taskType)
        else
            script = require("GamePlay/BevTree/Bev" .. childData.taskType)
        end
        if script ~= nil then
            -- ** TODO:
            local node = script.ctor(childData)
            node.context = context
            parent:AddChild(node)
            CreateBevTreeChildren(node, childData.children, context)
        else
            error("BevTree", "no node " .. childData.type .. " was defined. 请检查有没有对应节点type的lua脚本!")
        end
        -- end
    end
end

function BevTree.CreateBevTree(aiFileName, context)
    if string.isnilorempty(aiFileName) then
        return
    end
    local data = require("AI/" .. aiFileName)
    local root = BevTree.ctor(data)
    -- ** 行为树需要使用的所有上下文信息记录在这个里面，这是实例化的行为树中所有节点共享的
    root.context = context or {}
    root.data = data
    CreateBevTreeChildren(root, root.children, root.context)
    return root
end

function BevTree.ctor(data)
    local nodes = data.nodes
    local allNodes = {}
    local rootNode
    -- ** 构造所有的Node
    for _, node in pairs(nodes) do
        local bevNode = BevNode.ctor(BevTree, node)
        allNodes[bevNode.uid] = bevNode
        bevNode.skipLog = true
        bevNode.historyLog = {}
        bevNode.historyLogCache = {}
        bevNode.colorIndex = 1
        bevNode.frameInfo = 1
        if rootNode == nil and bevNode.uid == data.primeNodeUid then
            rootNode = bevNode
        end
    end
    -- ** 根据Connection连接所有的Node到children字段
    local connections = data.connections
    local allConnections = {}
    for _, connection in pairs(connections) do
        allConnections[connection.uid] = connection
    end

    local Connect
    Connect = function(node)
        if node ~= nil then
            for _, out in pairs(node.data.outConnectionsUid) do
                local targetNode = allNodes[allConnections[out].targetNodeUid]
                table.insert(node.children, targetNode)
                Connect(targetNode)
            end
        end
    end
    Connect(rootNode)
    return rootNode
end

function BevTree:Init()
    self.context.currentTime = 0
    self.context.localVars = {}
    self.context.countDownVars = {}
    BevNode.Init(self)
end

function BevTree:Uninit()
    self.running = false
    BevNode.Uninit(self)
end

function BevTree:Reset()
    if self.running == nil or self.running == true then
        for k, _ in pairs(self.context.localVars) do
            self.context.localVars[k] = nil
        end
        for k, _ in pairs(self.context.countDownVars) do
            self.context.countDownVars[k] = nil
        end
        BevNode.Reset(self)
    end
end

function BevTree:Run(delta)
    local context = self.context
    if #self.children == 0 then
        return
    end
    if #self.children > 1 then
        warning("BevTree", "行为树根节点下有两个以上的节点，多于1个的节点永远不会被执行到！")
    end
    self.running = true
    context.currentTime = context.currentTime + delta
    context.deltaTime = delta
    for k, var in pairs(self.context.countDownVars) do
        self.context.countDownVars[k] = var - delta
    end

    local process = context.frequency == nil
    if context.frequency ~= nil and context.frequency > 0 then
        self.frequencyTime = self.frequencyTime or context.frequency
        self.frequencyTime = self.frequencyTime - delta
        if self.frequencyTime <= 0 then
            self.frequencyTime = context.frequency
            process = true
        end
    end

    if process then
        -- ** 这里只执行第一个子节点
        local startNode = self.children[1]
        local result = startNode:Run()
        startNode:LogRecord(result)
    end
end

return BevTree
