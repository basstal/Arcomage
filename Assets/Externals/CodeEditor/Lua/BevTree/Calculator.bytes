local modulus = 1 << 20
local multiplier = 9
local increment = 7

local Random = {}

function Random:next(min, max)
    self.v = (multiplier * self.v + increment) % modulus

    if min ~= nil and max ~= nil then
        return self.v % (max - min + 1) + min
    else
        return self.v / modulus
    end
end

function Random:getSeed()
    return self.v
end

function Random:setSeed(seed)
    self.v = seed
end

function Random:new(seed)
    return setmetatable({ v = seed }, { __index = self } )
end

local mRandom = Random:new(10000F)
local mRandomNoFixed = Random:new(10000)

local BevGlobalDataContainer = {}
local Calculator = {}
local Stack = {}

function Stack.create(stack)
    stack.s = {}
    stack.top = Stack.top
    stack.push = Stack.push
    stack.pop = Stack.pop
    stack.empty = Stack.empty
    return stack
end

function Stack.new()
    return Stack.create({})
end

function Stack.top(stack)
    return stack.s[#stack.s]
end

function Stack.push(stack, element)
    stack.s[#stack.s + 1] = element
end

function Stack.pop(stack)
    if #stack.s > 0 then
        local r = stack.s[#stack.s]
        table.remove(stack.s)
        return r
    else
        return nil
    end
end

function Stack.empty(stack)
    return #stack.s == 0
end


function Calculator.isWordStartChar(ch)
    local lowerAlphabet = ch >= string.byte('a') and ch <= string.byte('z')
    local upperAlphabet = ch >= string.byte('A') and ch <= string.byte('Z')
    local special = ch == string.byte('_')
    return lowerAlphabet or upperAlphabet or special
end

function Calculator.isWordChar(ch)
    local lowerAlphabet = ch >= string.byte('a') and ch <= string.byte('z')
    local upperAlphabet = ch >= string.byte('A') and ch <= string.byte('Z')
    local special = ch == string.byte('_')
    local number = ch >= string.byte('0') and ch <= string.byte('9')
    return lowerAlphabet or upperAlphabet or special or number
end

function Calculator.isNumber(ch)
    local number = ch >= string.byte('0') and ch <= string.byte('9')
    local dot = ch == string.byte('.')
    return number or dot
end

function Calculator.isOperator(ch)
    local leftBracket = ch == string.byte('(')
    local rightBracket = ch == string.byte(')')
    local add = ch == string.byte('+')
    local minus = ch == string.byte('-')
    local divide = ch == string.byte('/')
    local multiply = ch == string.byte('*')

    return leftBracket or rightBracket or add or minus or divide or multiply
end

function Calculator.getOperatorPriority(word)
    local add = word == '+'
    local minus = word == '-'
    local divide = word == '/'
    local multiply = word == '*'
    if add or minus then
        return 2
    elseif divide or multiply then
        return 3
    end
    return 1
end

function Calculator.isVarName(word)
    return Calculator.isWordStartChar(string.byte(word, 1))
end

function Calculator.isNumberToken(word)
    return Calculator.isNumber(string.byte(word, 1))
end

function Calculator.isLeftBracket(word)
    return word == "("
end

function Calculator.isRightBracket(word)
    return word == ")"
end

function Calculator.isOperatorToken(word)
    local add = word == '+'
    local minus = word == '-'
    local divide = word == '/'
    local multiply = word == '*'

    return add or minus or divide or multiply
end

function Calculator.getTokens(expression)
    local i = 1
    local state = "expecting_new_token"
    local token = ""
    local tokens = {}
    while i <= string.len(expression) do
        local ch = string.byte(expression, i)
        if state == "expecting_new_token" then
            if Calculator.isWordStartChar(ch) then
                token = token .. string.char(ch)
                state = "expecting_var_name_char"
            elseif Calculator.isNumber(ch) then   
                token = token .. string.char(ch)
                state = "expecting_number_char"
            elseif Calculator.isOperator(ch) then
                token = string.char(ch)
                tokens[#tokens + 1] = token
                token = ""
                state = "expecting_new_token" 
            end
            i = i + 1
        elseif state == "expecting_var_name_char" then
            if Calculator.isWordChar(ch) then
                token = token .. string.char(ch)
                i = i + 1
            else
                tokens[#tokens + 1] = token
                token = ""
                state = "expecting_new_token"
            end
        elseif state == "expecting_number_char" then
            if Calculator.isNumber(ch) then
                token = token .. string.char(ch)
                i = i + 1
            else
                tokens[#tokens + 1] = token
                token = ""
                state = "expecting_new_token"
            end
        end
    end

    if string.len(token) > 0 then
        tokens[#tokens + 1] = token
    end
    return tokens
end

function Calculator.getNpr(tokens)
    local stack = Stack.new()

    local nprTokens = {}

    for i = 1, #tokens do
        local token = tokens[i]
        if Calculator.isNumberToken(token) or Calculator.isVarName(token) then
            nprTokens[#nprTokens + 1] = token
        elseif Calculator.isLeftBracket(token) then
            stack:push(token)
        elseif Calculator.isOperatorToken(token) then
            while Calculator.getOperatorPriority(token) <= Calculator.getOperatorPriority(stack:top()) do
                nprTokens[#nprTokens + 1] = stack:pop()
            end
            stack:push(token)
        elseif Calculator.isRightBracket(token) then
            while not Calculator.isLeftBracket(stack:top()) do
                nprTokens[#nprTokens + 1] = stack:pop()
            end
            stack:pop()
        end
    end

    while not stack:empty() do
        nprTokens[#nprTokens + 1] = stack:pop()
    end
    return nprTokens
end

function Calculator.setVal(node, varname, var, isGlobal)
    if isGlobal then
        local root = node:Root()
        local globalData = BevGlobalDataContainer[root.data.name] or {}
        globalData[varname] = var
        BevGlobalDataContainer[root.data.name] = globalData
    else
        local localVars = node.context.localVars
        localVars[varname] = var
    end
end

function Calculator.eval(node, varname, isGlobal)
    if type(varname) == "number" then
        return varname
    end

    if tonumber(varname) ~= nil then
        return fixed.tofixed(varname)
    else
        local var
        if isGlobal then
            -- ** 根据行为树逻辑脚本的名称来决定，一个行为树逻辑脚本实例出来的所有行为树都共用这个全局变量
            local root = node:Root()
            local globalData = BevGlobalDataContainer[root.data.name]
            if globalData ~= nil then
                var = globalData[varname]
            end
        else
            local localVars = node.context.localVars
            var = localVars[varname]
        end
        if var ~= nil then
            if type(var) == "number" or fixed.isfix(var) then
                return var
            elseif tonumber(var) ~= nil then
                return fixed.tofixed(var)
            else
                return Calculator.calc(node, var, isGlobal)
            end
        end
    end    
end

function Calculator.evalNoFixed(node, varname, isGlobal)
    if type(varname) == "number" then
        return varname
    end

    if tonumber(varname) ~= nil then
        return tonumber(varname)
    else
        local var
        if isGlobal then
            -- ** 根据行为树逻辑脚本的名称来决定，一个行为树逻辑脚本实例出来的所有行为树都共用这个全局变量
            local root = node:Root()
            local globalData = BevGlobalDataContainer[root.data.name]
            if globalData ~= nil then
                var = globalData[varname]
            end
        else
            local localVars = node.context.localVars
            var = localVars[varname]
        end
        if var ~= nil then
            if tonumber(var) ~= nil then
                return tonumber(var)
            else
                return Calculator.calc(node, var, isGlobal, true)
            end
        end
    end    
end

function Calculator.calcTwoOperands(node, lhs, rhs, op, isGlobal, noFixed)
    local lval, rval
    if noFixed then
        lval = Calculator.evalNoFixed(node, lhs, isGlobal)
        rval = Calculator.evalNoFixed(node, rhs, isGlobal)
    else
        lval = Calculator.eval(node, lhs, isGlobal)
        rval = Calculator.eval(node, rhs, isGlobal)
    end
    if lval ~= nil and rval ~= nil then
        if op == "+" then
            return lval + rval
        elseif op == "-" then
            return lval - rval
        elseif op == "*" then
            return lval * rval
        elseif op == "/" then
            return lval / rval
        end
    end
    return 0
end

function Calculator.calc(node, expression, isGlobal, noFixed)
    local tokens = Calculator.getTokens(expression) 
    local nprTokens = Calculator.getNpr(tokens)
    local stack = Stack.new()

    for i = 1, #nprTokens do
        local token = nprTokens[i]

        if Calculator.isNumberToken(token) or Calculator.isVarName(token) then
            stack:push(token)
        elseif Calculator.isOperatorToken(token) then
            local operandR = stack:pop()
            local operandL = stack:pop()

            local result = Calculator.calcTwoOperands(node, operandL, operandR, token, isGlobal, noFixed)
            stack:push(result)
        end
    end

    if not stack:empty() then
        if Calculator.isVarName(stack:top()) then
            if noFixed then
                local ret = Calculator.evalNoFixed(node, stack:top(), isGlobal)
                return ret
            else
                local ret = Calculator.eval(node, stack:top(), isGlobal)
                return ret
            end
        else
            local ret = stack:top()
            return ret
        end
    end

    return 0
end

function Calculator.SetSeed(seed)
    mRandom:setSeed(seed)
end
    
-- 随机min-max之间的整数，不传参则为0-1的小数
function Calculator.Next(min, max, noFixed)
    if noFixed then
        return mRandomNoFixed:next(min, max)
    else
        return mRandom:next(min, max)
    end
end

-- 随机min-max之间的小数，不传参则为0-1的小数
function Calculator.Random(min, max, noFixed)
    if noFixed then
        min = min or 0
        max = max or 1
        return mRandomNoFixed:next() * (max - min) + min
    else
        min = min or 0F
        max = max or 1F
        return mRandom:next() * (max - min) + min
    end
end


function Calculator.CompareValue(lhs, rhs, opt)
    if opt == PBEnum.CodeCompareOperation.Equal then
        return lhs == rhs
    elseif opt == PBEnum.CodeCompareOperation.NotEqual then
        return lhs ~= rhs
    elseif opt == PBEnum.CodeCompareOperation.BiggerThan then
        return lhs > rhs
    elseif opt == PBEnum.CodeCompareOperation.LessThan then
        return lhs < rhs
    elseif opt == PBEnum.CodeCompareOperation.BiggerThanOrEqual then
        return lhs >= rhs
    elseif opt == PBEnum.CodeCompareOperation.LessThanOrEqual then
        return lhs <= rhs
    end
end

return Calculator
